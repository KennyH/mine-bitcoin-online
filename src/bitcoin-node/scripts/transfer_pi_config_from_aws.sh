#!/bin/bash

# --- Configuration ---
TERRAFORM_ENV_DIR="./dev" # Default environment directory
PI_USER="pi"              # Default Pi user
PI_HOSTNAME=""            # Pi hostname/IP (REQUIRED - no default)
PI_REMOTE_CONFIG_DIR="/home/${PI_USER}/.aws-iot-credentials" # Default remote directory

# --- Help Function ---
show_help() {
    cat << EOF
Usage: $0 [OPTIONS]

This script transfers AWS IoT credentials and configuration from your
Terraform deployment to your Raspberry Pi.

Options:
  -e, --environment <dir>  Specify the Terraform environment directory (default: ${TERRAFORM_ENV_DIR})
  -u, --pi-user <user>     Specify the user on the Raspberry Pi (default: ${PI_USER})
  -h, --pi-hostname <host> Specify the hostname or IP address of the Raspberry Pi (REQUIRED)
  -d, --remote-dir <dir>   Specify the remote directory on the Pi for credentials (default: ${PI_REMOTE_CONFIG_DIR})
  --help                   Show this help message and exit

Examples:
  $0 --pi-hostname 192.168.1.100
  $0 -e ./prod -u myuser -h mypi.local
EOF
}

# --- Parse Command Line Options ---
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -e|--environment) TERRAFORM_ENV_DIR="$2"; shift ;;
        -u|--pi-user) PI_USER="$2"; shift ;;
        -h|--pi-hostname) PI_HOSTNAME="$2"; shift ;;
        -d|--remote-dir) PI_REMOTE_CONFIG_DIR="$2"; shift ;;
        --help) show_help; exit 0 ;;
        *) echo "Unknown parameter passed: $1"; show_help; exit 1 ;;
    esac
    shift
done

# --- Validation ---
if [ -z "$PI_HOSTNAME" ]; then
    echo "Error: Raspberry Pi hostname or IP (--pi-hostname) is required."
    show_help
    exit 1
fi

# Update default remote directory based on specified user
PI_REMOTE_CONFIG_DIR="/home/${PI_USER}/.aws-iot-credentials"


# --- Get Terraform Outputs ---
echo "Getting Terraform outputs for environment: ${TERRAFORM_ENV_DIR}"
if [ ! -d "$TERRAFORM_ENV_DIR" ]; then
    echo "Error: Terraform environment directory not found: ${TERRAFORM_ENV_DIR}"
    exit 1
fi

# Navigate to the environment directory to run terraform output
pushd "${TERRAFORM_ENV_DIR}" > /dev/null
TERRAFORM_OUTPUTS=$(terraform output -json)
if [ $? -ne 0 ]; then
    echo "Error getting Terraform outputs. Ensure you have run 'terraform apply' successfully in ${TERRAFORM_ENV_DIR}."
    popd > /dev/null # Return to original directory
    exit 1
fi
popd > /dev/null # Return to original directory

# Parse outputs using jq
# Ensure these jq paths match your Terraform root module output names
IOT_CERTIFICATE_PEM=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_certificate_pem.value')
IOT_PRIVATE_KEY_PEM=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_private_key_pem.value')
IOT_THING_NAME=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_thing_name.value')
IOT_CERTIFICATE_ARN=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_certificate_arn.value')
IOT_ROLE_ALIAS_NAME=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_role_alias_name.value')
IOT_ASSUMED_ROLE_ARN=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_assumed_role_arn.value')
IOT_CREDENTIALS_ENDPOINT=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.btcnode_iot_credentials_endpoint.value')

# Check if required outputs were successfully parsed
if [ -z "$IOT_CERTIFICATE_PEM" ] || [ -z "$IOT_PRIVATE_KEY_PEM" ] || \
   [ -z "$IOT_THING_NAME" ] || [ -z "$IOT_CERTIFICATE_ARN" ] || \
   [ -z "$IOT_ROLE_ALIAS_NAME" ] || [ -z "$IOT_ASSUMED_ROLE_ARN" ] || \
   [ -z "$IOT_CREDENTIALS_ENDPOINT" ]; then
    echo "Error: Failed to parse one or more required Terraform outputs."
    echo "Please check your 'terraform output -json' and the jq paths in this script."
    exit 1
fi


# --- Download Amazon Root CA Certificate ---
echo "Downloading Amazon Root CA certificate..."
CA_CERT_FILE="AmazonRootCA1.pem"
wget -O "${CA_CERT_FILE}" "https://www.amazontrust.com/repository/${CA_CERT_FILE}"
if [ $? -ne 0 ]; then
    echo "Error downloading Amazon Root CA certificate."
    exit 1
fi

# --- Create Temporary Credential Files ---
echo "Creating temporary credential files..."
CERT_FILE="pi_node_certificate.pem.crt"
PRIVATE_KEY_FILE="pi_node_private.pem.key"
echo "$IOT_CERTIFICATE_PEM" > "$CERT_FILE"
echo "$IOT_PRIVATE_KEY_PEM" > "$PRIVATE_KEY_FILE"

# --- Create Pi Configuration File ---
echo "Creating Pi configuration file..."
PI_CONFIG_FILE="pi_aws_iot_config.sh" # Name of the config file to create for the Pi

# Add environment variables from local environment if they exist
AWS_REGION=${AWS_REGION:-} # Default to empty if not set locally

cat << EOF > "$PI_CONFIG_FILE"
#!/bin/bash
# AWS IoT Configuration for Raspberry Pi Node - Generated by transfer_pi_config.sh

# Source this file in your monitoring script
# example: source /home/${PI_USER}/.aws-iot-credentials/${PI_CONFIG_FILE}

export AWS_REGION="${AWS_REGION}" # Make sure this is set in the environment where this script is sourced!
export AWS_IOT_THING_NAME="${IOT_THING_NAME}"
export AWS_IOT_CREDENTIALS_ENDPOINT="${IOT_CREDENTIALS_ENDPOINT}"
export AWS_IOT_CERTIFICATE_ARN="${IOT_CERTIFICATE_ARN}"
export AWS_IOT_PRIVATE_KEY_PATH="${PI_REMOTE_CONFIG_DIR}/${PRIVATE_KEY_FILE}"
export AWS_IOT_CERTIFICATE_PATH="${PI_REMOTE_CONFIG_DIR}/${CERT_FILE}"
export AWS_CA_BUNDLE="${PI_REMOTE_CONFIG_DIR}/${CA_CERT_FILE}"
export AWS_ROLE_ARN="${IOT_ASSUMED_ROLE_ARN}"
export AWS_ROLE_SESSION_NAME="${IOT_THING_NAME}-session" # Example session name

# Optional: Include other configuration values. These require jq on the Pi
# export SUBMISSION_QUEUE_URLS='\$(echo "\$TERRAFORM_OUTPUTS" | jq -c ".btcnode_submission_queue_urls.value")' # Requires parsing JSON on the Pi
# export SUBMISSION_STATUS_TABLE_NAME="\$(echo "\$TERRAFORM_OUTPUTS" | jq -r ".btcnode_submission_status_table_name.value")"
# export CONFIGURED_NETWORKS='\$(echo "\$TERRAFORM_OUTPUTS" | jq -c ".btcnode_configured_networks.value")'

EOF

# --- Transfer Files to Pi Securely ---
echo "Transferring files to ${PI_USER}@${PI_HOSTNAME}:${PI_REMOTE_CONFIG_DIR}"

# Check if SSH connection is possible
if ! ssh "${PI_USER}@${PI_HOSTNAME}" "exit" 2>/dev/null; then
    echo "Error: Cannot connect to Pi via SSH. Ensure SSH is enabled on the Pi and you have configured key-based authentication for user '${PI_USER}' to '${PI_HOSTNAME}'."
    # Clean up temporary files before exiting
    rm "${CERT_FILE}" "${PRIVATE_KEY_FILE}" "${CA_CERT_FILE}" "${PI_CONFIG_FILE}" 2>/dev/null || true
    exit 1
fi


# Create the remote directory
ssh "${PI_USER}@${PI_HOSTNAME}" "mkdir -p ${PI_REMOTE_CONFIG_DIR}"

# Transfer the files
scp "${CERT_FILE}" "${PRIVATE_KEY_FILE}" "${CA_CERT_FILE}" "${PI_CONFIG_FILE}" "${PI_USER}@${PI_HOSTNAME}:${PI_REMOTE_CONFIG_DIR}/"
if [ $? -ne 0 ]; then
    echo "Error transferring files via scp."
    # Clean up temporary files before exiting
    rm "${CERT_FILE}" "${PRIVATE_KEY_FILE}" "${CA_CERT_FILE}" "${PI_CONFIG_FILE}" 2>/dev/null || true
    exit 1
fi

# Set strict permissions on the Pi
ssh "${PI_USER}@${PI_HOSTNAME}" "chmod 600 ${PI_REMOTE_CONFIG_DIR}/*"


# --- Cleanup Temporary Files ---
echo "Cleaning up temporary files..."
rm "${CERT_FILE}" "${PRIVATE_KEY_FILE}" "${CA_CERT_FILE}" "${PI_CONFIG_FILE}" 2>/dev/null || true

echo "Successfully transferred AWS IoT configuration to the Pi."
echo "The configuration file is located at ${PI_REMOTE_CONFIG_DIR}/${PI_CONFIG_FILE} on the Pi."
echo "Remember to source this file in your Pi's monitoring script to load the environment variables."
